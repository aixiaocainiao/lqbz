void*指针
void*指针表示无类型指针 4字节
1.void*指针类型用来定义变量
void* p;
p = NULL;
一、C语言
2.void*指针（无类型指针）但可以指向任何一种类型的数据，即其他类型的指针可以不通过强制类型转换直接赋值给void*指针

void *p;
int* a;
p =a;
float *f;
p = g;
注意:在 C 语言当中，对指针类型的转换要求不是那么严苛，可以不通过强制转换就可以进行相互间的赋值
int* a = NULL;
float* b= NULL;
char* c = NULL;
a = b;
b = c;
c = a;
虽然编译器（gcc 6.3版本）不会显示有错误，编译照常会通过。只是会给出类似下面的警告：
警告 C4133 “=”: 从“float *”到“int *”的类型不兼容

二、C++
注意：
而在 C++ 当中，这一点要求就明显比较严格了。它不允许两个不同的类型指针相互赋值，除了 void * 指针。

1、其他的类型指针可以把值直接赋给 void * 指针，但反过来，void * 指针的值想要赋值给其他类型的指针，也需要通过强制转换。
ex:
void *p = NULL;
int* a = (int*)p;//通过
float *b = p;//错误

2、void * 指针还有一个非常强大之处，在函数定义的时候，作为参数。当调用的时候，无论什么类型的类型指针或数组都可以正常运行。
#include <iostream>
int test(void* dst){ };
int main()
{
    char *c = "123456";
    int arr[] = {1,2,3,4,5,6};
    test(c)；  //正常编译
    test(arr);//正常编译
    return 0;

}
注意:
不过 void * 指针也有一个致命的缺点，当对该指针进行算数操作，就会显示以下这个错误。
int main()
{
   void *p;
   p++;//错误
   //表达式必须是指向完整对象类型的指针



}
根据 ANSI C 标准规定，进行算数操作的指针，必须明确知道该指针所指向的数据类型大小。也就是所指向的数据，都必须是具体的类型，而不是空泛的 void 类型
